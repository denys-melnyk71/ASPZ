## Завдання:
Бібліотечна функція qsort призначена для сортування даних будь-якого типу. Для її роботи необхідно підготувати функцію порівняння, яка викликається з qsort кожного разу, коли потрібно порівняти два значення.
Оскільки значення можуть мати будь-який тип, у функцію порівняння передаються два вказівники типу void* на елементи, що порівнюються.
- Напишіть програму, яка досліджує, які вхідні дані є найгіршими для алгоритму швидкого сортування. Спробуйте знайти кілька масивів даних, які змушують qsort працювати якнайповільніше. Автоматизуйте процес експериментування так, щоб підбір і аналіз вхідних даних виконувалися самостійно.
- Придумайте і реалізуйте набір тестів для перевірки правильності функції qsort.

## Звіт:
### Опис основного функціоналу:
Вимірювання швидкості сортування відбувається в сегменті коду:
```c
clock_t start = clock();
qsort(arr, n, sizeof(int), cmp_int);
clock_t end = clock();
```

В циклі тестуємо усі вхідні данні та визначаємо індекс найгірших
```c
for (int i = 0; i < test_count; ++i) {
    double time = test_sort(&tests[i], n);
    printf("%-30s: %.6f с\n", tests[i].description, time);

    if (time > max_time) {
        max_time = time;
        worst_index = i;
    }
}
```
В кінці виводимо результат

### Результат:
```
Тестуємо qsort з масивами розміру 1000000:
-------------------------------------------
Випадковий масив: 0.187500 с
Відсортований масив: 0.015625 с
Реверсно відсортований масив: 0.015625 с
Масив з однакових елементів: 0.007812 с
-------------------------------------------
НАЙГІРШИЙ ВИПАДОК ДЛЯ qsort: Випадковий масив (0.187500 с)
```
